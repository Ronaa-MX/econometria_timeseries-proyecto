---
title: "Pronóstico serie de tiempo de red espacial"
author: "Aarón Ortiz Mendoza"
output: html_notebook
editor_options: 
  markdown: 
    wrap: 72
---

# Motivos

Buscando aplicar las técnicas de pronóstico **Box-Jenkins** para series
de tiempo espacio-temporales para conocer sus condiciones respecto al
tipo de serie **ARIMA**. Se hara un prónostico a una serie de tiempo
espacio-temporal dondé se busca realizar a los nodos con más ponderados
por sus vértices del grafo y de la demanda total semanal del grafo.

# Problématica

Se trabaja con un tipo de dato de una red espacial, para el dataset\
espacio-temporal de las entregas semanales de la aplicación **PedalMe**
en Londres, conteniendo una lista de vértices ponderada y una serie de
tiempo de las demandas semanales del 2020 al 2021 por nodo. Se busca
pronosticar la demanda semanal del por cada nodo relevante, donde se
tiene en total 15 y de la demanda promedio total de todos los nodos
semanalmente.

## Paquetes

```{r}
#Instalación de paquetes a utilizar
install.packages(c("dplyr", "tidyr", "lubridate","igraph", "starma"
))

#Paquetes a usar
library(dplyr)
library(tidyr)
library(lubridate)
library(igraph)
library(starma)

```

## Análisis del grafo

Trabajamos con un grafo de 15 nodos y 15 vérticos, no dirigidos con
ponderación entre cada uno, unos más grandes que otros donde veremos los
5 primeros nodos con mayor valor ponderado entre cada uno. Crearamos: 

- Matriz de adyaciencia ente los nodos con su ponderación 
- Gráfica de
conexión entre los nodos con sus vértices en base a su ponderación

```{r}
edges <- read.csv("pedalme_edges.csv")

g <- graph_from_data_frame(edges, directed = FALSE)
E(g)$weight <- edges$weight

matriz_adyacencia <- as.matrix(
  as_adjacency_matrix(g, attr = "weight", sparse = FALSE)
)
diag(matriz_adyacencia) <- 0
```

```{r}
summary(E(g)$weight)
hist(E(g)$weight, main = "Distribución de pesos", xlab = "Peso")
```

```{r}
heatmap(matriz_adyacencia,
        Rowv = NA, Colv = NA,
        scale = "none",
        main = "Mapa de calor del grafo ponderado")

```

```{r}
# Dimensiones y estructura
dim(edges)
str(edges)

# Primeras filas
knitr::kable(head(edges, 10),
             caption = "Lista de vértices ponderados del grafo")
```

```{r}
summary(edges$weight)
```

## Gráfica del grafo con pesos

```{r}
# Leer el dataset de edges

# Crear grafo
g <- graph_from_adjacency_matrix(matriz_adyacencia, mode = "undirected", weighted = TRUE)

layout_fr <- layout_with_fr(g, weights = E(g)$weight)

plot(g,
     layout = layout_fr,
     vertex.size = 10,
     vertex.color = "lightblue",
     vertex.label.dist = 1.5,
     vertex.label.cex = 0.8,
     vertex.label.color = "darkblue",
     edge.width = sqrt(E(g)$weight) * 3,
     edge.color = rgb(0,0,0,0.3),
     main = "Grafo ponderado de bicicletas")
```

## Matriz de Adyaciencia del grafo con pesos

```{r}
#Matriz de Adyaciencia
write.csv(matriz_adyacencia, "matriz_adyacencia.csv", row.names = FALSE)
```

```{r}
panel <- read.csv("pedalme_features.csv") %>%
  mutate(
    date = as.Date(ISOdate(year, 1, 4)) + weeks(week - 1)
  ) %>%
  select(date, year, week, node, demand) %>%
  arrange(date, node)
```

```{r}
network_weekly <- panel %>%
  group_by(date) %>%
  summarise(total_demand = sum(demand), .groups = "drop") %>%
  arrange(date)
```

## Análisis de serie de Tiempo de demanda completa

```{r}
library(tsibble)
library(feasts)
network_ts <- network_weekly %>%
  mutate(week_index = yearweek(date)) %>%
  as_tsibble(index = week_index) %>%
  fill_gaps(total_demand = 0)
```

## Método de Box-Jenkins

```{r}
library(ggplot2)

autoplot(network_ts, total_demand)
```
```{r}
acf(network_ts$total_demand, lag.max = 52)
pacf(network_ts$total_demand, lag.max = 52)
```

## Análisis de series de tiempo por demanda de nodo

```{r}
node_summary <- panel %>%
  group_by(node) %>%
  summarise(total_demand = sum(demand))

top5_nodes <- node_summary %>%
  arrange(desc(total_demand)) %>%
  slice(1:5) %>%
  pull(node)

weekly_top5 <- panel %>%
  filter(node %in% top5_nodes) %>%
  group_by(date, year, week, node) %>%
  summarise(demand = sum(demand), .groups = "drop") %>%
  pivot_wider(names_from = node, values_from = demand) %>%
  arrange(date)
```

